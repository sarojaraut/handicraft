11 Managing Undo Data

Undo data is the information needed to reverse the effects of DML statements. It is often referred to as rollback data, but try to avoid that term. In earlier releases of Oracle, the terms rollback data and undo data were used interchangeably, but from 9i onward they are different: their function is the same, but their management is not. Whenever a transaction changes data, the preupdate version of the data is written out to a rollback segment or to an undo segment. The difference is crucial. Rollback segments can still exist in an 11g database, but with release 9i of the database Oracle introduced the undo segment as an alternative. Oracle strongly advises that all databases should use undo segments

Query to determine whether the database is using undo segments or rollback segments

select value from v$parameter where name='undo_management';

This should return the value AUTO. If it does not, issue this command, and then restart the instance:
alter system set undo_management=auto scope =spfile;

what are the undo tablespaces available
select tablespace_name from dba_tablespaces  where contents='UNDO';

Which undo tablespaces are in use

select value from v$parameter where name='undo_tablespace';

Determine what undo segments are in use in the database, and how big they are:

select tablespace_name,segment_name,segment_id,status from dba_rollback_segs;

select usn,rssize from v$rollstat;

Find out how much undo data was being generated in your database in the recent past:

alter session set nls_date_format='dd-mm-yy hh24:mi:ss';
select begin_time, end_time,
(undoblks * (select value from v$parameter where
name='db_block_size'))
undo_bytes from v$undostat;

When a transaction starts, Oracle will assign it to one (and only one) undo segment. Any one transaction can only be protected by one undo segment—it is not
possible for the undo data generated by one transaction to cut across multiple undo segments. This is not a problem, because undo segments are not of a fixed size. So if a transaction does manage to fill its undo segment, Oracle will automatically add another extent to the segment, so that the transaction can continue. It is possible for multiple transactions to share one undo segment, but in normal running this should not occur.

One feature of undo management is that Oracle will automatically spawn new undo segments on demand, in an attempt to ensure that it is never necessary for transactions to share undo segments. when the workload drops Oracle will shrink and drop the segments, again automatically.

As a transaction updates table or index data blocks, the information needed to roll back the changes is written out to blocks of the assigned undo segment. All this happens in the database buffer cache. Oracle guarantees absolutely the A, for atomicity, of the ACID test, meaning that all the undo data must be retained until a transaction commits. If necessary, the DBWn will write the changed blocks of undo data to the undo segment in the datafiles. By default, Oracle does not, however, guarantee the C, for consistency, of the ACID test. Oracle guarantees consistency to the extent that if a query succeeds, the results will be consistent with the state of the database at the time the query started—but it does not guarantee that the query will actually succeed.

Atomicity - The classic example is that of woman walking into a bank and asking to transfer $500 from her checking account to her savings account. Behind the scenes, two SQL statements are executed: one that subtracts $500 from her checking-account balance and one that adds $500 to her savings-account balance. Either both and debit and credit will success or both will fail.

Active undo is undo data that might be needed to roll back transactions in progress. This data can never be overwritten, until the transaction completes. At the other extreme, expired undo is undo data from committed transactions, which Oracle is no longer obliged to store. This data can be overwritten if Oracle needs the space for another active transaction. Unexpired undo is an intermediate category; it is neither active nor expired: the transaction has committed, but the undo data might be needed for consistent reads, if there are any long-running queries in progress. Oracle will attempt not to overwrite unexpired undo.

select * from regions as of timestamp to_timestamp('10-02-2013 00:00:00', 'dd-mm-yy hh24:mi:ss');

Error Conditions Related to Undo
The principles are simple: first, there should always be sufficient undo space available to allow all transactions to continue, and second there should always be sufficient undo data available for all queries to succeed. The first principle requires that your undo tablespace must be large enough to accommodate the worst case for undo demand. It should have enough space allocated for the peak usage of active undo data generated by your transaction workload. Note that this might not be during the highest number of concurrent transactions; it could be that during normal running you have many small transactions, but the total undo they generate might be less than that generated by a single end-of-month batch job. The second principle requires that there be additional space in the undo tablespace to store unexpired undo data that might be needed for read consistency.

If a transaction runs out of undo space, it will fail with the error ORA-30036, “unable to extend segment in undo tablespace.” The statement that hit the problem is rolled back, but the rest of the transaction remains intact and uncommitted. The algorithm that assigns space within the undo tablespace to undo segments means that this error condition will only arise if the undo tablespace is absolutely full of active undo data.

If a query encounters a block that has been changed since the query started, it will go to the undo segment to find the preupdate version of the data. If, when it goes to the undo segment, that bit of undo data has been overwritten, the query fails on consistent read with a famous Oracle error ORA-1555, “snapshot too old.”  

If the undo tablespace is undersized for the transaction volume and the length of queries, Oracle has a choice: either let transactions succeed and risk queries failing with ORA-1555 or let queries succeed and risk transactions failing with ORA-30036. The default behaviour is to let the transactions succeed, to allow them to overwrite unexpired undo.  

There are three parameters controlling undo: UNDO_MANAGEMENT, UNDO_TABLESPACE, and UNDO_RETENTION. 
UNDO_MANAGEMENT defaults to AUTO with release 11g. It is possible to set this to MANUAL, meaning that Oracle will not use undo segments at all.

If you are using UNDO_MANAGEMENT=AUTO, you must also specify UNDO_TABLESPACE. This parameter nominates a tablespace, which must have been created as an undo tablespace, as the active undo tablespace

Lastly, UNDO_RETENTION, set in seconds, is usually optional. It specifies a target for keeping inactive undo data and determines when it becomes classified as expired rather than unexpired. If, for example, your longest running query is thirty minutes, you would set this parameter to 1800. Oracle will then attempt to keep all undo data for at least 1800 seconds, and your query should therefore never fail with ORA-1555. If, however, you do not set this parameter, or set it to zero, Oracle will still keep data for as long as it can anyway. The algorithm controlling which expired undo data is overwritten first will always  choose to overwrite the oldest bit of data; therefore, UNDO_RETENTION is always at the maximum allowed by the size of the tablespace.

The undo retention is only a target that Oracle will try to achieve. But there may be circumstances when successful queries are considered more important than successful transactions.

----------- Sybex Book
SQL> ALTER SYSTEM SET UNDO_RETENTION=14400
SCOPE=BOTH;
System altered
When AUM (Automatic Undo management) encounters a manual undo retention setting, it will honor the setting only if it is using an auto-extending tablespace. If AUM is configured with a fixed-size tablespace, it will ignore the setting and will instead follow its default behavior of dynamically setting the retention time based on system activity and available disk space.

As mentioned previously, Oracle will violate the undo retention period if it is required to prevent transactions from failing. For most users, it is a fair trade-off. However, there may be situations where it is more important to guarantee the retention period, even at the expense of failed transactions. This can be accomplished by specifying the RETENTION GUARANTEE clause on the undo tablespace. This can either be done when initially creating the tablespace or by altering the tablespace, as shown here:
SQL> ALTER TABLESPACE UNDOTBS1 RETENTION GUARANTEE;
-----------
The undo tablespace should be large enough to store the worst case of all the undo generated by concurrent transactions, which will be active undo, plus enough unexpired undo to satisfy the longest running query. You may also have to add space to allow for flashback queries as well. The algorithm is simple: calculate the rate at which undo is being generated at your peak workload and multiply by the length of your longest query. There is a view, V$UNDOSTAT, that will tell you all you need to know.

Creating and Managing Undo Tablespaces
CREATE UNDO TABLESPACE tablespace_name
DATAFILE datafile_name SIZE size
[ RETENTION NOGUARANTEE | GUARANTEE ] ;

By default, the tablespace will not guarantee undo retention. This characteristic can be specified at tablespace creation time, or set later: 

ALTER TABLESPACE tablespace_name retention [ GUARANTEE | NOGUARANTEE ] ;

It is not possible to create segments in an undo tablespace, other than the undo segments that will be created automatically.
Initially, there will be a pool of ten undo segments created in an undo tablespace. More will be created if there are more than ten concurrent transactions. Oracle will monitor the concurrent transaction rate and adjust the number of segments as necessary

No matter how many undo tablespaces there may be in a database, generally speaking only one will be in use at a time. The undo segments in this tablespace will have a status of online (meaning that they are available for use); the segments in any other undo tablespaces will have status offline. There are two exceptions to this:

In a RAC database, every instance opening the database must have its own undo tablespace. This can be controlled by setting the UNDO_TABLESPACE parameter to a different value for each instance.

If the undo tablespace is changed by changing the UNDO_TABLESPACE parameter, any segments in the previously nominated tablespace that were supporting a transaction at the time of the change will remain online until the transaction finishes.

select tablespace_name,contents,retention from dba_tablespaces; 

Undo tablespaces will dispalyed with contents as UNDO, meaning that it can only be used for undo segments, and that retention is NOGUARANTEE.

select BEGIN_TIME,END_TIME,UNDOBLKS,MAXQUERYLEN from V$UNDOSTAT;

to find out the optimal undo size, devide UNDOBLKS by the number secoonds between begintime and endtime. then multily this value with the maxquerylen ad multiply by blocksize in bytes.

create undo tablespace smallundo datafile 'D:\ORADATA\SMALLUNDO.DBF' size 200k; 
alter system set undo_tablespace=smallundo;
select segment_id, segment_name, tablespace_name, status from dba_rollback_segs;
create table undotest as select * from all_objects where 1=2;
insert into undotest select * from all_objects;
select count(*) from undotest;
There are no rows in the table because the insertion was rolled back.
alter database datafile 'D:\ORADATA\SMALLUNDO.DBF' autoextend on;
insert into undotest select * from all_objects;
select xidusn,USED_UBLK from v$transaction;
select bytes from v$datafile where name='D:\ORADATA\SMALLUNDO.DBF';
delete from undotest;

The Oracle database guarantees transactional integrity absolutely, but not necessarily read consistency. If the undo system is not appropriately configured, queries may fail because a lack on undo data—but if a query succeeds, it will be consistent. This behavior can be modified by enabling the RETENTION GUARANTEE, though this may mean that transaction fail.

-------------------- DBA Handbook

create database ord
user sys identified by ds88dkw2
user system identified by md78s233
sysaux datafile '/u02/oradata/ord/sysaux001.dbf' size 1g
default temporary tablespace temp01
tempfile '/u03/oradata/ord/temp001.dbf' size 150m
undo tablespace undotbs01
datafile '/u01/oradata/ord/undo001.dbf' size 500m;


create undo tablespace undotbs02
datafile '/u01/oracle/rbdb1/undo0201.dbf'
size 500m reuse autoextend on;

