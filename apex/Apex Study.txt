Interview Questions
access page items in Javascript
function firstName(){  alert('First Name is ' + document.getElementById('P1_FIRST_NAME').value );

•How can you clear caches programmaticaly? (APEX_UTIL.CLEAR_APP_CACHE, APEX_UTIL.CLEAR_PAGE_CACHE, APEX_UTIL.CLEAR_USER_CACHE

•How will you code dynamic PL/SQL regions (HTP.P code)?

Running an On Demand Process from a Page Request
f?p=application_id:page_id:session:APPLICATION_PROCESS=process_id
 suppose you need to display the contents of a user's shopping cart with each page view.
 Instead of writing a process for each page to set the values of TOTAL_CART_ITEMS and TOTAL_PURCHASE_PRICE, you could write an application process of type On Load: Before Header to compute these values. 
 Condition > SQL, PLSQL, Request = value, item =value, current page, item or request are null, not null numeric, does not contain space 
 •What are the ways to get the session values? (&SESSION., :APP_SESSION, v(‘SESSION’) or nv())
 •How will you validate whether the session is valid? APEX_CUSTOM_AUTH.IS_SESSION_VALID
 •How will you submit jobs / back ground processes in Oracle APEX? APEX_PLSQL_JOB.SUBMIT_PROCESS
 •Name few important APEX functions? (APEX_UTIL, APEX_MAIL, APEX_ITEM
 •Differentiate Application Admin and Workspace Admin.
App admin > Workspace preferences, activity report, dash bord (database > recently modified program units, recently created table, object count etc, application > , developer activity etc)

Workspace admin > Manage instance, manage wokspace, monitor activity etc

Beginning Oracle Application Express 4.2 2nd Edition
----------------------------------------------------

APEX is a 100% browser-based rapid application development (RAD) tool that helps you to create rich interactive Oracle-based web applications very quickly and with relatively little programming effort.

APEX is built on and uses as its core languages SQL and PL/SQL. This is a huge advantage for those of you who have already been working with the Oracle database because it means you can immediately draw on what you know.
APEX is a declarative tool that provides a feature-rich core designed to make your job easier. Because APEX takes care of many of the underlying functions common to all web-based applications, you can focus on the logic specific to your application.

A large share of what you need to accomplish can be done using one of the many built-in wizards provided as part of the APEX Application Builder. The wizards walk you through the process of defining what you want your application to do and then store that information as metadata.

APEX 4.0 (2010) was a huge leap forward, introducing dynamic actions and plug-ins:
APEX 5.0 (2015) : Improved developer productivity by page builder, more than one IR on a page, pivoting in IR, in built modal window, Universal Theme

APEX was designed from the beginning to be a multi-tenant architecture where many different development environments (called workspaces) can exist in a single APEX instance.

Instance - Workspace - Applications- Schemas

Workspace - Applications - Pages - Regions - Items

APEX Users

Instance Administrators : manage and maintain the overall APEX instance. They can set instance level preferences and messages, create and manage workspaces, monitor space utilization, and perform many other actions related to the overall APEX installation. Instance Administrators are only able to log in to the special INTERNAL workspace, which houses the APEX Admin Services application.

Workspace Administrators : managing the details of a specific workspace and can manage user accounts related to the workspace, monitor workspace activity, view
log files, override developer locks and settings, and so on. Although it isn’t good practice, the Workspace Administrator can also act as a Developer, creating and modifying applications.

Developers : Create and edit the applications in the workspace. They have access to the underlying tables in the schema(s) assigned to the workspace and may
create and modify database objects and stored PL/SQL units. Most people writing APEX applications only need this level of access.

End Users  : Only able to run applications in a workspace. They don’t have direct access to any of the underlying database objects, nor do they have access to any of the APEX development modules. End users can’t log directly into a workspace.

Note : Because APEX applications are portable and may not necessarily be run in the same schema they were developed in, it’s not good practice to hard code the schema names into your SQL or PL/SQL. Instead use the substitution variable #OWNER#, is substituted for the actual “parse as” schema for the application at runtime. 

select * from #OWNER#.emp

Apex Developer IDE main page : 

Developer Login : http://gba71011:6954/apex > Application builder, SQL Workshop, Team Development, Packaged Apps
Instance Administrator Login : http://gba71011:6954/apex/apex_admin > Manage Request, Manage Instance, Manage Workspace, Monitor Activity
If you login as workspace administrator administration tab will be shown in navigation bar(Top Right corner)
Menu bar has drop down items under it as well as default action is defined when you wlick directly on it. Ex if you click on "SQL Workshop", it will take you to the "SQL Workshop" home page, you also can click on the sub menu items available in the drop down menu.

Clicking on any Application will take you to the application home page, It has a IR. You can customize the way you want to see the data. Page related task and recently edited pages are shown along the right side of this page.

By default, all sQl statements executed via the sQl Commands interface are automatically committed. to override this setting and enter into transactional mode, uncheck the autocommit check box in the toolbar. once this is done, you can manually commit and roll back your sQl statement. there is no way to turn off autocommit permanently, so you need to remember to do this any time you want to enter.

The SQL Workshop Utilities section gives you access to tools and reports that help you view and manage information about the underlying database objects and their data.

The architecture of APEX may seem a bit daunting at first, but once you actually start working with it, things will begin to fall into place and you’ll understand more and more about how everything fits together.

System Design with APEX in Mind

• Placing comments on a table column seeds that item’s UI Default help text with the text of the comment.
• Marking a column as NOT NULL at the database level triggers a Required flag to be set in the UI Defaults.
• Date and Timestamp data types are set up to display as Date Pickers on input forms. 
• The order in which the columns appear in the table is the default order in which the UI Defaults set them to display on a form or report.
• Defining a column as a BLOB sets the form-level UI Defaults to use APEX’s declarative blob functionality.
• Create look up tables, to be used in LOV. e.g status open, closed, draft, pending.

If you create a look up table using SQL Workshop > Object Browser. It will give you an option of selecting a column from the table normalises the table and create another lookup table, sequence and foreign key constraint.

User Interface Defaults > What would be the table name in form, in report, Region, Column to include or not, default column alignment, lebel name in pages, Help Text(Comment)

SQL Workshop> Utilities > Table dictionary/ Attribute Dictionary

Remeber the Anonymous blocks, queries entered directly in apex pages are stored in meta data. Each time they’re required to run, they must first be extracted from the APEX
metadata, parsed, compiled, and then run. If you move that code into a stored program unit in the database, the retrieval, parse, and compile steps are all skipped.

As a general rule of thumb, logic that controls or manipulates the UI is best placed in APEX, and logic that implements business rules or controls the data is best placed in stored program units in the database.

Chapter 5 - Applications and Navigation

Navigation Bar Entries : Each APEX application has one navigation bar that may contain multiple entries. Examples of links typically displayed on every page are Login, Logout, Help, and My Account. Placement of navigation bars is dictated by the page template substitution variable #NAVIGATION_BAR#. In most applications, the navigation bar is placed either at upper right or upper left on the page.  Navigation bar entries can be modified to include images. Entries can be based on conditions, authorization schemes, and build options.

Navigation bars are part of an application’s shared components, so they’re created and maintained from the Shared Components section of the Application Builder.

Breadcrumb Regions : Breadcrumbs are a popular navigation structure. They give the user a quick and intuitive representation of the current navigation path with optional functionality to navigate back using the structure. When you’re creating new pages of an application, the Create Page wizard has an option to assist in creating new breadcrumb entries. When you use this option, child pages receive a copy of the breadcrumb region from the parent as well as an automatic entry in the Breadcrumb group.

Lists : As the name implies, a list is a structure that APEX uses to keep a collection of data for links. The list structure allows menus to be displayed consistently across numerous application pages. Don’t confuse navigation lists with lists of values (LOVs). Lists are a navigational structure with built-in templates for displaying information in different ways. LOVs are used to support data entry, limiting the options a user can enter.

List templates have a lot of capability. They support hierarchical lists, graphical bullets, dynamic HTML, and highlighting for the current page. Lists can contain data in a parent-child relationship; some list templates are specifically designed to display parent-child data Apex 5 universal theme lists can be displayed as drop down menu.

Lists of Values : One of the fundamental benefits of writing an application on top of a database architecture is the ability to enforce data quality. LOVs are an APEX component that can be mapped to different item types including Select Lists, Multiple Select Lists, Checkboxes, and Radio Groups.

It can be static or dynamic. static will ask for a set of display value and return value. Dynamic is a out of query in the format :
select 
ename as d,
       empno as r
from emp
order by 1

Chapter 6 - Forms and Reports—The Basics

Most applications contain a series of forms, reports, charts, and other elements designed to display, edit, and collect data. Forms are used to display, edit, and collect data, which is then sent back to the database for processing. Forms can interface with tables, views , procedures (Typically collects values to pass on to the procedure for further processing), and web services.

Forms can be created on views pointing to tables over db link.
Once created underlying table/view name can be changed.

The APEX wizards do handle most of the work of creating a form for you. However, you may need to change the item lebel, optional/required, add validations

Master-Detail Report and Form

Understanding Session State : Session state is what allows APEX to keep track of all the values that belong in a particular user’s APEX session. Session state is particularly useful for keeping track of values as a user moves from page to page in the application. Unlike a stateful database application, where a connection is maintained continuously and all values retain their value until changed or removed or until the session ends, an APEX application doesn’t maintain a continuous connection
to the database. APEX is a stateless system—the APEX engine generates HTML pages based on directives stored in the APEX repository.

The APEX engine has a built-in session-state management component. This session-state management is an integral part of APEX—it can’t be disabled or circumvented. 

You can use a procedure with out parameter. and out parameter can be set to a page item.

#OWNER#.P_TMAP_AMS_MANFEST(
MANIFEST_ID => :P9_NIFEST_ID,
TEAM_CD => :P9_AM_CD,
REPORTING_DATE => :P9_PORTING_DATE,
REPORTING_TYPE => :P9_PORTING_TYPE,
ETL_ACTIVE_INDICATOR => :P9_L_ACTIVE_INDICATOR,
MANIFEST_STATUS_CD_ID => :P9_NIFEST_STATUS_CD_ID
O_MSG => :P9_OUTPUT -- out parameter);

you may convert the procedure to function afterwards

Setting and Retrieving Session State

When within an APEX process, you can set an item equal to a value, like so: :P1_ITEM_NAME := 'some value';
In PL/SQL, when in a stored procedure, you can use the apex_util.set_session_state procedure to set a value in session state: apex_util.set_session_state( 'P1_ITEM_NAME', 'some value');

The syntax to retrieve session state for an item varies according to where you’re referencing the item. In templates or regions, tabs, menus, or lists, use the following substitution-string syntax (and don’t forget the trailing dot!): &P1_ITEM_NAME.

Use the following syntax in SQL statements: :P1_ITEM_NAME
From Anonymous PL/SQL block: :P1_ITEM_NAME
PL/SQL Unit Called from APEX: V('P1_ITEM_NAME')
      NV('MY_NUMERIC_ITEM'), Use standard PL/SQL syntax referencing the numeric item value using the NV function.
Within conditions, use this syntax: P1_ITEM_NAME

APEX Items : There are two types of APEX items: page items, which are displayed to the user on a page, and application items, which hold values in an application but aren’t displayed.
Application items aren’t associated with a page and have no UI properties. They hold values in an application that are essential but not necessarily displayed. You can use an application item much like a global variable.

Built-In Items
• APP_ID: The application identifier of the currently running application
• APP_ALIAS: The application alias of the currently running application
• APP_USER: The currently signed-on user
• APP_SESSION: The session identifier of the currently signed-on user
• APP_PAGE_ID: The currently running page identifier

APEX URL Syntax
http://apex.somewhere.com/pls/apex/f?p=4350:1:220883407765693447

This example indicates:
¦ http: is the scheme.
¦ apex.somewhere.com is the domain name of the server. It can also include a port number or an IP address.
¦ pls is the indicator to use the mod_plsql cartridge (if applicable)
¦ apex is the Database Access Descriptor (DAD) name. The DAD describes how HTTP Server connects to the database server so that it can fulfill an HTTP request. The default value is apex.
¦ f?p= is a prefix used by Oracle Application Express to route the request to the correct engine process.
¦ 4350 is the ID of the application being called. The application ID is a unique number that identifies each application.
¦ 1 is the number of the page within the application.
¦ 220883407765693447 is the session number. When you run an application, the Application Express engine generates a session number that serves as a key to the user's session state.

f?p=App:Page:Session:Request:Debug:ClearCache:itemNames:itemValues:PrinterFriendly

f?p is the call to the f PL/SQL procedure passing the argument p.
itemNames : Comma-delimited list of item names used to set session state with a URL.
itemValues : List of item values used to set session state within a URL. To pass a comma in an item value, enclose the characters with backslashes. For example:
\123,45\
Every character sequence except backslash comma (\,) can be enclosed with backslash.

f?p=&APP_ID.:5:&APPSESSION.::NO::P2_ID:1234 - Calls page 5 of the current application using the current session, not in Debug mode, setting the value of P2_ID to 1234
f?p=100:5:&APP_SESSION.::NO:MY_ITEM - calls page 5 of application 100. Placing MY_ITEM in the ClearCache position of the f?p syntax resets the value of MY_ITEM to NULL.
Example: Clearing Cache for Two Pages and Resetting Pagination This example clears the session cache for two pages and resets pagination.
f?p=6000:6003:&APP_SESSION.::NO:RP,6004,6014 -  Clears all values maintained by the current session's cache for items of pages 6004 and 6014. Resets region pagination (RP) on page 6003 (the requested page).

Beginning Oracle Application Express 4.2 2nd Edition
-----------------------------------------------------
Oracle Application Express is a hosted declarative development environment for developing and deploying database-centric web applications.

When you create or extend an application, Oracle Application Express creates or modifies metadata stored in database tables. When the application is run, the Application Express engine then reads the metadata and displays the application. To provide stateful behavior within an application, Oracle Application Express transparently manages session state in the database.

Your browser sends a URL request that is translated into the appropriate Oracle Application Express PL/SQL call. After the database processes the PL/SQL, the results are relayed back to your browser as HTML. This cycle happens each time you either request or submit a page.

Oracle Application Express does not use a dedicated database connection. Instead, each request is made through a new database session, consuming minimal CPU
resources. Application session state is managed in the database tables by the Application Express engine.

Behind the scenes, the Application Express engine renders and processes pages. The Application Express engine also performs these tasks:

¦ Session state management
¦ Authentication services
¦ Authorization services
¦ Page flow control
¦ Validation processing

An application is an HTML interface that exists on top of database objects such as tables or procedures. You create both database applications and Websheet applications using the Create Application Wizard. The main difference between these two types of applications is the intended audience. While database applications are primarily developed by application developers, Websheet applications are often created by end users with no development experience.

What Is an Application Page?
Every application consists of one or multiple pages. Each page can have buttons and fields (called items) which are grouped into containers called regions. Pages can include application logic (or processes). You can branch from one page to the next using conditional navigation; perform calculations (called computations); perform validations (such as edit checks); and display reports, calendars, and charts. You can view and edit a page in two views: Page Designer and Component View.

Page Designer and Component View - During Page edit
Page Designer is a full featured Integrated Development Environment (IDE) designed to maximize developer productivity in maintaining application pages. The Page Designer window is divided into three main sections.

¦ Tree Pane (Rendering) - The Tree pane displays in the left column and features the following tree views: Rendering, Dynamic Actions, Processing, and Shared Components.

¦ Grid Layout - Grid Layout displays in the center column. Grid Layout is a visual representation of the regions, items, and buttons that define a page. You can edit the position of page components by dragging and dropping them. You can also add new regions, items, and button by dragging and dropping them from Gallery at the bottom of the tab.

¦ Property Editor - The Property Editor displays in the right column. Use the Property Editor to edit the properties of the component currently selected in the Tree Pane or Grid Layout.

Tip: The Rendering tree and Grid Layout are two different representations of the regions, items, and buttons that define a page.

Component View is the traditional user interface for editing a page in Application Builder. Unlike Page Designer, Component View does not offer a visual representation of a page or support the dragging and dropping of page components. To preview the position of components on a page, you must run it.

The Component View window is divided into the following sections:

¦ Page Rendering. Page rendering is the process of generating a page from the database. Use the Page Rendering section to modify controls that impact the rendering of a page, including page attributes, regions, buttons, items, page rendering computations, and page processes.

¦ Page Processing. Page processing is the process of submitting a page. A page is typically submitted when a user clicks a button. Use the Page Processing section to
specify application logic such as computations, validations, processes, and branches. In general, the Application Express engine runs this logic in the order it appears on the page. 

¦ Shared Components. The Shared Components section lists common components that can be used by one or more pages within an application.

Use Theme 25 to create a responsive design or Universal list based theme.

How Does Page Processing and Page Rendering Work?

To view a rendered version of your application, you request it from the Application Express engine with a URL. When you run an application, the Application Express engine relies on two processes:

¦ Show Page is the page rendering process. It assembles all the page attributes (including regions, items, and buttons) into a viewable HTML page.
¦ Accept Page performs page processing. It performs any computations, validations, processes, and branching.

When you request a page using a URL, the engine is running Show Page. When you submit a page, the Application Express engine is running Accept Page or performing page processing during which it saves the submitted values in the session cache and then performs any computations, validations, or processes.

Understanding Conditional Rendering and Processing

What is a Condition?
A condition is a small unit of logic that helps you control the display of regions, items, buttons, and tabs and the execution of processes, computations, and validations. For example, when you apply a condition to a button, the rendering engine evaluates the condition during the rendering (or Show Page)

Condition Example: 
Current Page in Expression 1 : Evaluates to true if the current page number is contained within the comma-delimited list of pages provided.
Exists : If the query returns at least one row, then the condition evaluates as true. (SELECT 1 FROM employees WHERE department_id = :P101_DEPTNO)
Above example references item P101_DEPTNO as a bind variable. You can use bind variables within application processes and SQL query regions to reference items from session state.
PL/SQL Expression : Use PL/SQL Expression to specify an expression in valid PL/SQL syntax that evaluates to true or false. For example: NVL(:MY_ITEM,'NO') = 'YES'

About Verifying User Identity
Authentication is the process of establishing users' identities before they can access an application. Authentication may require a user to enter a user name and password, or may involve the use of a digital certificate or a secure key. Oracle Application Express supports modular authentication, making it easy to switch authentication methods when needed.

While conditions control the rendering and processing of specific controls or components on a page, authorization schemes control user access. Authorization is a
broad term for controlling access to resources based on user privileges.

Authorization schemes use the identities established by authentication to grant privileges on applications and objects within them. You can specify an authorization scheme for an entire application, a page, or a specific page control such as a region, item, or button. For example, you could use an authorization scheme to selectively determine which tabs, regions, or navigation bar entries a user sees.

Hypertext Transfer Protocol (HTTP), the protocol over which HTML pages are most often delivered, is a stateless protocol. A web browser is only connected to the server for as long as it takes to download a complete page. In addition, each page request is treated by the server as an independent event, unrelated to any page requests that happened previously or that may occur in the future. To access form values entered on one page on a subsequent page, the values must be stored as session state. Oracle Application Express transparently maintains session state and provides developers with the ability to get and set session state values from any page in the application. 

A user runs an application in a single Oracle Application Express session from sign in to sign out with a typical duration measured in minutes or hours. Each page requested during that session results in the Application Express engine creating or reusing an Oracle database session to access database resources.

Understanding URL Syntax



About Using f?p Syntax to Link Pages

You can create links between pages in your application using the following f?p syntax:
f?p=App:Page:Session:Request:Debug:ClearCache:itemNames:itemValues:PrinterFriendly

Session : Identifies a session ID. You can reference a session ID to create hypertext links to other pages that maintain the same session state by passing the session number. You can reference the session ID using the syntax:
¦ Short substitution string: &SESSION.
¦ PL/SQL: V('SESSION')
¦ Bind variable: :APP_SESSION

Request : Sets the value of REQUEST. Each application button sets the value of REQUEST to the name of the button which enables accept processing to reference the name of the button when a user clicks it. You can reference REQUEST using the syntax:
¦ Substitution string: &REQUEST.
¦ PL/SQL: V('REQUEST')
¦ Bind variable: :REQUEST

ClearCache : Clears the cache. This sets the value of items to null. To clear cached items on a single page, specify the numeric page number. To clear cached items on multiple pages, use a comma-separated list of page numbers. Clearing a page's cache also resets any stateful processes on the page.

itemNames : Comma-delimited list of item names used to set session state with a URL.
itemValues : List of item values used to set session state within a URL. To pass a comma in an item value, enclose the characters with backslashes. For example:
\123,45\
Every character sequence except backslash comma (\,) can be enclosed with backslash.

Application Alias - An Application Alias is a unique alternate alphanumeric application identifier that developers can use in place of the application ID. You define an Application Alias editing the Application Definition.

Page Alias - A Page Alias is a unique alternate alphanumeric for a page number. Developers can use a Page Alias in place of the page number ID. You define a Page Alias by editing the page attributes.

About Referencing Session State - You can reference item values stored in session state in regions, computations, processes, validations, and branches. An item can be a field, a text area, a password, a select list, or a check box.

SQL - Standard item syntax: :MY_ITEM or Syntax for items containing special characters: :"MY_ITEM"
PL/SQL - V('MY_ITEM'), Use PL/SQL syntax to reference an item value using the V function. V function is a short hand for APEX_UTIL.GET_SESSION_STATE.
PL/SQL - NV('MY_NUMERIC_ITEM'), Use standard PL/SQL syntax referencing the numeric item value using the NV function. You can use the shorthand, NV function, in place of APEX_UTIL.GET_NUMERIC_SESSION_STATE.
Static text (exact) - Standard item syntax: &MY_ITEM. Syntax for items containing special characters: &"MY_ITEM". For static text or an exact substitution, use the convention &ITEM_NAME followed by a period (.).

Setting Session State
You can set the value of an item in your application and therefore set session state using the following methods:

1. About Setting Session State with a Form Submission : When a user submits a page, the Application Express engine automatically stores values typed into fields (items) in session state. For example, suppose you have an application containing two pages. The first page of the application contains a form in which a user can enter a phone number. You defined this form by creating an item named P1_PHONENO. On the second page, you want to display the information the user enters in the form. 

When the page is submitted, Oracle Application Express captures the value entered in the phone number field and stores the value for future use. On the second page, the phone number entered by the user can then be retrieved from session state using the name P1_PHONE_NO with the appropriate syntax.

2. Clearing Session State : As you develop your applications, you may find it useful to clear the cached value for specific items, all items on a page, all pages in an application, or the current user session. Clearing a cached value resets the value to null.

About Clearing Cache for an Item

The following example uses standard f?p syntax to clear the cache for an item. This example calls page 5 of application 100. Placing MY_ITEM in the ClearCache position of
the f?p syntax resets the value of MY_ITEM to NULL.



The following example resets the value of the items THE_EMPNO and THE_DEPTNO:
f?p=100:5:&APP_SESSION.::NO:THE_EMPNO,THE_DEPTNO

Clearing Cache for All Page Items
There are occasions when you may want to clear the cache for all items on a page. For example, suppose you needed to clear all fields on a page when a user clicks a link that creates a new order. By clearing the cache for an entire page, you set the value of all items on the page to null.



In this example

¦ Runs page 6003 of application 6000 and uses the current session ID.
¦ Indicates to not show debug information (NO).
¦ 


Example: Clearing Cache on a Page and Passing an Item Value This example shows how to implement an update form. It clears existing information and sets the item's value
(typically a primary key).

f?p=6000:6003:&APP_SESSION.::NO:6003:MY_ITEM:1234

This example:
¦ Runs page 6003 of application 6000 and uses the current session ID
¦ Indicates to not show debug information (NO)
¦ Clears all values maintained by the current session's cache for items on page 6003
¦ Sets the session state of an item called MY_ITEM to the value 1234

Example: Clearing Session Cache on a Page and Passing Values to Multiple Items This example demonstrates how to implement an update form. It clears existing information, sets the item's value (typically a primary key), and passes values to multiple items.

f?p=6000:6004:&APP_SESSION.::NO:6003:MY_ITEM1,MY_ITEM2,MY_ITEM3:1234,,5678

This example:
¦ Runs page 6004 of application 6000 and uses the current session ID
¦ Clears the current session's cache for items on page 6003
¦ Indicates to not show debug information (NO)
¦ Sets the value of MY_ITEM1 to 1234, sets the value of MY_ITEM2 to null (indicated by the comma used as placeholder), and sets the value of MY_ITEM3 to 5678

Example: Clearing Cache for an Entire Application. This example clears the application’s cache by using f?p syntax and creating a Clear Cache argument using the keyword APP.
f?p=App:Page:Session::NO:APP

Another approach to clearing an application’s cache is to create a Clear Cache argument using the keyword SESSION. For example:
f?p=6000:6004:12507785108488427528::NO:SESSION

Referencing Session State Using Bind Variable Syntax

You can use bind variables syntax anywhere in Oracle Application Express where you are using SQL or PL/SQL to reference session state of a specified item. For example:
SELECT * FROM employees WHERE last_name like '%' || :SEARCH_STRING || '%'
In this example, the search string is a page item. If the region type is defined as SQL Query, you can reference the value using standard SQL bind variable syntax.

When using bind variable syntax, remember the following rules:
¦ Bind variable names must correspond to an item name.
¦ Bind variable names are not case-sensitive.
¦ Bind variable names cannot be longer than 30 characters (that is, they must be a valid Oracle identifier).

Although page item and application item names can be up to 255 characters, if you intend to use an application item within SQL using bind variable syntax, the item name must be 30 characters or less.

About Using Bind Variables in Regions Based on a SQL Query or LOV If your region type is defined as a SQL Query, SQL Query (plsql function body returning SQL query), or list of values (LOV), you can reference session state using the following syntax:
:MY_ITEM

One common way to do this is to incorporate a session state variable in a WHERE clause. The following example shows how to bind the value of the item THE_DEPTNO into a region defined from a SQL Query.

SELECT last_name, job_id, salary
FROM employees
WHERE department_id = :THE_DEPTNO

Understanding Substitution Strings
You can use substitution strings in Application Builder in the following ways:
¦ Include a substitution string within a template to reference component values
¦ Reference page or application items using &ITEM. syntax
¦ Use built-in substitution strings

Substitution Strings within Templates
Special substitution strings available within a template are denoted by the number symbol (#). For example:
#ABC#

Substitution Strings for Page or Application Items
To reference page or application items using substitution variables:
1. Reference the page or application item in all capital letters.
2. Precede the item name with an ampersand (&).
3. Append a period (.) to the item name.
For example, you would refer to an application item named F101_X in a region, a region title, an item label, or in any of numerous other contexts in which static text is
used, for example: &F101_X.

Using Built-in Substitution Strings

APP_ID : APP_ID identifies the application ID of the currently executing application.

Bind variable :APP_ID
Direct PL/SQL APEX_APPLICATION.G_FLOW_ID (A NUMBER)
PL/SQL NV('APP_ID')
Substitution string &APP_ID.

APP_ALIAS : APP_ALIAS is an alphanumeric name for the current application. APP_ALIAS is different from the APP_ID in that the APP_ID must be unique over all workspaces and all applications hosted in one database. In contrast, APP_ALIAS must be unique within a workspace.

APP_PAGE_ID : APP_PAGE_ID is the current application page ID. For example, if your application was on page 3, then the result would be 3.

APP_SESSION : APP_SESSION is the most commonly used built-in substitution strings. You can use this substitution string to create hypertext links between application pages that maintain a session state by passing the session number.

Bind variable :APP_SESSION
PL/SQL V('APP_SESSION')
Short PL/SQL V('SESSION')
Substitution string &APP_SESSION.
SYS_CONTEXT variable SYS_CONTEXT('APEX$SESSION', 'APP_SESSION')

Consider the following examples:
¦ From within an HTML region:
<a href="f?p=100:5:&APP_SESSION.">click me</a>
¦ Using PL/SQL:
htf.anchor('f?p=100:5:'||V('APP_SESSION'),'click me');
¦ Using a SQL query:
SELECT htf.anchor('f?p=100:5:'||:APP_SESSION,'click me') FROM DUAL;
¦ Using the SYS_CONTEXT variable:
SELECT ... WHERE apex_session_id = SYS_CONTEXT('APEX$SESSION', 'APP_SESSION')

APP_USER : APP_USER is the current user running the application. Depending upon your authentication model, the value of the user is set differently. If the application is running using database authentication, then the value of the user is the same as the database pseudo column USER. If the application uses an authentication scheme that requires the user to authenticate, the value of APP_USER is set by the authentication scheme, usually to the user name used during authentication.

REQUEST : Each application button sets the value of REQUEST to the name of the button or to the request value attribute associated with the button, enabling accept processing to reference the name of the button when a user clicks it. In the f?p syntax, REQUEST may be set using the fourth argument. REQUEST is typically referenced during Accept processing (that is, the processing that occurs when you post a page).

About Scope and Value of REQUEST for Posted Pages : When you post a page, you initiate Accept processing. Accept processing consists of computations, validations, processes, and branches. The value of REQUEST is available during each phase of the Accept processing. Once an application branches to a different page then REQUEST is set to NULL.

The value of REQUEST is the name of the button the user clicks, or the name of the tab the user selects. For example, suppose you have a button with a name of CHANGE, and a label Apply Change. When a user clicks the button, the value of REQUEST is CHANGE.

About the When Button Pressed Attribute : Validations, processes, and branches have a When Button Pressed attribute. This attribute displays as a select list and contains the names of buttons that exist on the current page. If you make a selection from When Button Pressed, you associate the button’s REQUEST value with the validation, process, or branch.
When you use a button to submit a page, the REQUEST value is passed to the page. The Accept processing logic evaluates each validation, process, and branch that uses a
When Button Pressed attribute to determine whether the component should run (or fire). When one of these components runs, do not assume that a user actually clicked the associated button and caused the page to be submitted. Keep in mind, that another button using the same request value may have submitted the page. Similarly, JavaScript on the page can also submit the page and pass in a request value.

About Referencing REQUEST Using Declarative Conditions : Many developers reference REQUEST using conditions. For example, you may want to reset pagination when a user clicks Go on a report page. You can reset pagination by creating an on-submit page process. The page process can be made conditional using the condition Request = Expression 1.

To conditionalize an on-submit page process:
1. Under Condition, select the condition type Request = Expression 1.
2. In Expression 1, enter GO.

About Using REQUEST for Show Processing : You can also use REQUEST for Show processing when navigating to a page using f?p syntax. For example:
f?p=100:1:&APP_SESSION.:GO

Remember that the fourth argument in the f?p syntax is REQUEST. This example goes to application 100, page 1 for the current session, and sets the value of REQUEST to GO. Any process or region can reference the value of REQUEST using Show processing. The following is a similar example using PL/SQL:
IF V ('REQUEST') = 'GO' THEN
htp.p('hello');
END IF;
Note that htp.p('hello') is a call to a PL/SQL Web Toolkit package to print the specified text string.


Planning

Installation and configuration
Workspace creation and user provision
Authentication method 
Shared Components
Re-usable components
Do you have any specific preference for date and time format
Substituation Variables
Images, Java scripts
CSS Classes


Sample data loading - Outer Region
position content body
Template - Login
ICon CSS Classes - app-sample-data-loading

User Name - Trim spaces - Leading and Trailing ,Template Hidden, Value Placeholder-username, width - 64, post text - <span class="t-Login-iconValidation a-Icon icon-check"></span>

<span class="t-Login-iconValidation a-Icon icon-check"></span>

ICon CSS Classes - 
app-sample-data-loading
icon-login-username
icon-login-password, template hidden
Login button - button position Next, button template text, 

Regions

Region Position -1
Page Template Body

<p>Data  lupload  in a easy and declarative  system </p>


Wizard


Data Load Source
Data / Table Mapping
Data Validation
Data Load Results


Universal Theme
Built-in building blocks for your apps
 
Browse through the various APEX components that are part of Universal Theme. Each component type contains several individual templates which can be easily customized using Template Options.

Pages 
Standard Page, Left Side Column, Right Side Column, Both Side Columns, Master Detail, Dialog Pages, Other Pages

Right Side Column - This page template features a collapsible right-side display position and is especially useful for displaying action-oriented controls such as buttons or lists.

Master Detail - This page template features a collapsible right side column and a title-bar area which contains primary information. This page template is well suited for displaying master-detail relationships.

Dialog Pages - These page templates can be loaded as either modal or non-modal (pop-up) dialogs and are very useful for displaying commonly used forms, reports, and other components.

The Login page template provides an elegant user interface for your app's log in page. The Minimal Page page template is useful for single page applications or pages where navigation is not necessary.

Regions 
All the templates for grouping elements and widgets in your apps.

Standard - The generic region template. It works well with all widgets and can be heavily customized.
Use Default :Yes, Show Maximize Button : Yes, Body Height: 240px, AccentAccent:2, Advanced Body : Overflow

Alert - Notify your users with alerts, confirmations, and other action-oriented messages. Set Alert as Region Template. 
Region Template Options -  
                      Default - Use DefaultYes, Alert IconsShow Default Icons, Alert TypeWarning, Alert DisplayHorizontal
                      Wizard Style - Use DefaultYes, Highlight BackgroundYes, Alert DisplayWizard, Alert IconsShow Default Icons, Alert TypeSuccess
                      Custom Icon - Use DefaultYes, Alert IconsShow Custom Icons. Alert TypeInformation. Alert DisplayWizard
Hero - Capture your users' attention on homepage, dashboard, and other introductory-style pages. This region template displays an icon, heading and sub headings, and buttons. Set Hero as Region Template.
Region Template Options : 
                        Default : Use DefaultYes
Buttons Container - Organize your button bars, toolbars, and simple horizontal forms. Set Buttons Container as Region Template.
Carousel - Show off one sub region at a time. For example, displaying a report and a chart, a slideshow, or different views of the same data.
Region Template Options : 
 Default : Use DefaultYes, Advanced Body OverflowHide, AnimationSpin
 Spin And cycle : Use DefaultYes, AnimationSpin, Timer5 Seconds, Advanced Body Overflow
Collapsible -  Allow your users to toggle the visibility of a region's content on the page. Set Collapsible as Region Template.
Region Template Options :  Default : Use DefaultYes, Default StateExpanded, Advanced Body Overflow
                           Collapsible state : Use DefaultYes ,Default StateCollapsed ,Advanced Body Overflow
                           Scrolling Body : Use DefaultYes, Body Height240px, Default StateExpanded, Advanced Body Overflow
Title Bar - Group breadcrumbs, page title, and primary page actions at the top of the page. Set Title Bar as Region Template.
Region Template Options : 
   Default : Use DefaultYes, Region TitleUse Current Breadcrumb Entry,  Breadcrumb Template Options,  Use DefaultYes
   Breadcrumbs and Region Title : Use DefaultYes ,Region TitleUse Region Title,  Breadcrumb Template Options,  Use DefaultYes
   Region Title Only : Use DefaultNo ,Region TitleUse Region Title , Breadcrumb Template Options,  Use DefaultYes

Wizard - Use this region template for the Wizard Progress list, and as the container for your forms. Set Wizard Container as Region Template.
Region Template Options : 
      Default :  Use DefaultYes, Hide Steps ForSmall Screens (Tablet), List Template Options,  Use DefaultYes, Label DisplayCurrent Step Only
      Wizard with title : Use DefaultYes, Show TitleYes, Hide Steps ForX Small Screens (Mobile), List Template Options,  Use DefaultYes, Label DisplayCurrent Step Only
      Simple : Use DefaultNo, Hide Steps ForSmall Screens (Tablet),  List Template Options,  Use DefaultYes, Label DisplayHide Labels

Lists
Lists are a very versatile component within APEX and can be used as the foundation for any number of UI components. This page introduces you to the List Templates and Template Options found in Universal Theme.

Media List - This list template is a very common design pattern involving an icon, heading, description, and a badge. Set Media List as the List Template.
List Template Options : 
      Default : Use DefaultYes
      Variation 1 : Use DefaultNo, Show IconsYes, Show BadgesYes
      Variation 2 : Use DefaultYes, Layout2 Column Grid
Cards - This list template provides the Cards UI and is useful for presenting a variety of information. Cards can be displayed in three styles, with icons or initials, and you can control the layout. Set Cards as the List Template.
List Template Options :
      Default : 
 Use DefaultYes
StyleFeatured
Layout2 Columns
IconsDisplay Icons
Color AccentsUse Theme Colors
Body Text2 Lines

------ AMS

Data Model
Firebug
Mozilla, Chrome, Opera, Safari browsers

Keep usage of PLSQL to the minimum, if required keep these all inside a package -> simple to mantain, tune, debug, 
User Interface Defaults
Base tables - tables without any foreign key, table to be shown as LOV
When creating list of values, always use the aliases d and r or display_value and return_value for the two columns in the query, just to be clear which values are displayed and returned.

-----

Best Practices

Runtime or full development environment
Build Status > When importing or exporting an application the Run Application Only or Run and Build Application options can be selected.
Changing the Build Status to Run and Build Application can only be done as the admin user of the workspace internal. In the APEX Administration Services, choose Manage Workspaces and then select Manage Applications | Build Status.

Choosing a web server
• Oracle HTTP Server (OHS)
• Embedded PL/SQL Gateway (EPG)
• APEX Listener
In simple terms, the web server maps the URL in a web browser to a procedure in the database. Everything the procedure prints with sys.htp package, is sent to the browser of the user.

Oracle more or less recommends the use of APEX Listener. Given the functionality, enhanced security, file caching, flexibility of deployment possibilities, and feature announcements makes it the best choice.

Creating a second administrator : Sometimes admin account gets locked due to wrong passwords provided by users. If the account is already locked, we have to unlock it first. This can be easily done by running the apxchpwd.sql script.
Creating secods admin user from APEX web interface
login to internal workspace as admin user, Make sure that Internal is selected in the Workspace field and APEX_xxxxxx is selected in Default Schema, and that the new user is an administrator. xxxxxx has to match your APEX scheme version in the database, for instance, APEX_040100.

User Interface Defaults : This option isn't used very much in practice, but it's a very useful utility. With User Interface Defaults, we populate initial values and control the appearance and behavior of items when using them in reports and items (in forms). User Interface Defaults can accelerate your development and result in less repetition of tasks in APEX. provide consistency across multiple pages for all the applications in our workspace.

APEX provides two types of dictionaries for this purpose:
Attribute Dictionary : The Attribute Dictionary consists of a simple set of attributes. The definitions are matched only by column name, and a particular definition can be shared amongst several columns by creating synonyms.
Table Dictionary : In the Table Dictionary, the defaults are defined by table and column combinations. The Table Dictionary is more specific than the Attribute Dictionary, because more properties can be defined in this one. When processed during the use of a creation wizard for a region or item, an entry in the Table Dictionary takes priority over an entry in the Attribute Dictionary.

Another functionality of the Table Dictionary is the use of Column Groups. Related columns within a table can be grouped together. In forms, these groups appear as separate regions
Creating User Interface Defaults : SQL Workshop > Utilities > User Interface Defaults.

• If we have too many columns, we can use a form on the table with a report to layout the columns neatly in the form. We could also use this approach when we have a few columns. If we do not want the user to switch between too many pages, we can generate both the form and report on one single page. We can accomplish that by filling in the same page number for the form and report in the wizard. After that we may want to place the report above the form.

Base tables
We begin with base tables that we have to maintain. These base tables are often used in LOVs. A way to recognize a base table is to look at the number of foreign keys. It's also good practice to group these pages together on a separate tab with a name such as Basic Data or System.

If there are a few columns in the base table, we can use a tabular form if the total width of all the columns is not too wide when placed side by side. We don't want the user to scroll horizontally.

If we have too many columns, we can use a form on the table with a report to layout the columns neatly in the form. We could also use this approach when we have a few columns. If we do not want the user to switch between too many pages. we can generate both the form and report on one single page. We can accomplish that by filling in the same page number for the form and report in the wizard.

2 - Leveraging the Database

https://tylermuth.wordpress.com/2009/11/03/logger-a-plsql-logging-and-debugging-utility/

Code instrumentation - If you just whip together an application and throw it out there without any thought to monitoring it over time, be prepared to have poor performance and no clue as to why or where.

no network, no application time, just the database ?? you would not know where even to begin.

Also, make this instrumentation part of the production code, don’t leave it out!  Why?  Because, funny thing about production – you are not allowed to drop in “debug” code at the drop of a hat, but you are allowed to update a row in a configuration table, or in a configuration file!  Your trace code, like Oracle’s should always be there, just waiting to be enabled.

Good Looking Interface, visually attractive

Analytic functions cannot be used in the WHERE clause or the final ORDER BY clause. To circumvent this limitation, you can push the analytic function into an inline view.
Another way of circumventing the limitation with ORDER BY is to use a column alias in the ORDER BY clause.

-----------

create or replace function ams_authorisation
(
    p_username in varchar2
   ,p_password in varchar2
) 
return boolean 
as     
    l_pw_check varchar2(1); 
begin     
    select  'x'    
    into    l_pw_check     
    from    tmap_ams_user     
    where   upper(user_name) = upper(p_username)
    and     user_password = p_password;

    apex_util.set_authentication_result(0);
    return true; 
exception 
    when no_data_found 
    then
        apex_util.set_authentication_result(4);
        return false; 
end ams_authorisation;

create table tmap_ams_user(user_name varchar2(30), user_password varchar2(30))

----------

content body Region template > login
text box template type to hidden
place holder text
Icon CSS Classes - app-sample-data-loading
CSS Classes - icon-login-username, icon-login-password
Edit application properties >user interface > edit desktop > navigation menu > position=top> List = top navigation menu
Moses, Manifests, Cubes , User Maintenance , Reference Data , Cube Reference Data
Templates, Manifests , Manifest Assignments ,Manifest Authorisations, Manifest Versions


------------- Testing

create or replace function P_TMAP_AMS_MANFEST
 ( 
MANIFEST_ID                  number,
TEAM_CD                      number,
REPORTING_DATE               date,
REPORTING_TYPE               number,
ETL_ACTIVE_INDICATOR         number,
MANIFEST_STATUS_CD_ID        number
)
return varchar2
is
begin
insert into VTMAP_AMS_MANFEST_NEW values
(
MANIFEST_ID          
,TEAM_CD              
,REPORTING_DATE       
,REPORTING_TYPE       
,ETL_ACTIVE_INDICATOR 
,MANIFEST_STATUS_CD_ID
);
commit;

--apex_util.set_session_state( 'P9_OUTPUT', 'Processed Successfully');
return V('P9_NIFEST_ID')||' : Completed Successfully.';

end;
/


#OWNER#.P_TMAP_AMS_MANFEST(
MANIFEST_ID => :P9_NIFEST_ID,
TEAM_CD => :P9_AM_CD,
REPORTING_DATE => :P9_PORTING_DATE,
REPORTING_TYPE => :P9_PORTING_TYPE,
ETL_ACTIVE_INDICATOR => :P9_L_ACTIVE_INDICATOR,
MANIFEST_STATUS_CD_ID => :P9_NIFEST_STATUS_CD_ID
O_MSG => :P9_OUTPUT);


:P9_OUTPUT = #OWNER#.P_TMAP_AMS_MANFEST(
MANIFEST_ID => :P9_NIFEST_ID,
TEAM_CD => :P9_AM_CD,
REPORTING_DATE => :P9_PORTING_DATE,
REPORTING_TYPE => :P9_PORTING_TYPE,
ETL_ACTIVE_INDICATOR => :P9_L_ACTIVE_INDICATOR,
MANIFEST_STATUS_CD_ID => :P9_NIFEST_STATUS_CD_ID);